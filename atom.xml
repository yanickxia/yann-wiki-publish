<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yanick&#39;s Wiki</title>
  
  <subtitle>30岁の魔法师营地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wiki.yanick.site/"/>
  <updated>2020-06-25T13:59:35.970Z</updated>
  <id>http://wiki.yanick.site/</id>
  
  <author>
    <name>yanick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>inoreader 无法显示图片</title>
    <link href="http://wiki.yanick.site/wiki/tips/inoreader-can-not-show-pic/"/>
    <id>http://wiki.yanick.site/wiki/tips/inoreader-can-not-show-pic/</id>
    <published>2020-06-23T16:27:50.000Z</published>
    <updated>2020-06-25T13:59:35.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>安装 <code>referer control</code> 禁止 inoreader 向第三方站点发送 referrer</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.v2ex.com/amp/t/562142" rel="external nofollow noopener noreferrer" target="_blank">inoreader 图片不显示是什么情况</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h1&gt;&lt;p&gt;安装 &lt;code&gt;referer control&lt;/code&gt; 禁止 inoreader 向第三方站点发送 referrer
      
    
    </summary>
    
      <category term="tips" scheme="http://wiki.yanick.site/categories/tips/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux Device Driver 笔记</title>
    <link href="http://wiki.yanick.site/wiki/linux/ldd/"/>
    <id>http://wiki.yanick.site/wiki/linux/ldd/</id>
    <published>2020-06-20T16:09:25.000Z</published>
    <updated>2020-06-25T13:59:35.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>先下载 Linux 源码，然后准备到开发驱动的必须前置工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make oldconfig</span><br><span class="line">make prepare</span><br><span class="line">make modules_prepare</span><br></pre></td></tr></table></figure><h1 id="编译-Helloworld"><a href="#编译-Helloworld" class="headerlink" title="编译 Helloworld"></a>编译 Helloworld</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vigith/Linux-Device-Drivers.git</span><br><span class="line"></span><br><span class="line">make -C /root/linux-2.6.32.4/ M=`<span class="built_in">pwd</span>` modules</span><br></pre></td></tr></table></figure><p>-C: 指定 Linux 源码位置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prepare&quot;&gt;&lt;a href=&quot;#Prepare&quot; class=&quot;headerlink&quot; title=&quot;Prepare&quot;&gt;&lt;/a&gt;Prepare&lt;/h1&gt;&lt;p&gt;先下载 Linux 源码，然后准备到开发驱动的必须前置工作&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="linux" scheme="http://wiki.yanick.site/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>常见虚拟机挂载共享目录问题</title>
    <link href="http://wiki.yanick.site/wiki/virtualmachine/mount-file/"/>
    <id>http://wiki.yanick.site/wiki/virtualmachine/mount-file/</id>
    <published>2020-06-06T16:27:50.000Z</published>
    <updated>2020-06-25T13:59:35.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware-Functions"><a href="#VMware-Functions" class="headerlink" title="VMware Functions"></a>VMware Functions</h1><p>试试这个</p><p><img src="https://s1.ax1x.com/2020/06/15/NPe0PS.png" alt="NPe0PS.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure><h1 id="Virtualbox"><a href="#Virtualbox" class="headerlink" title="Virtualbox"></a>Virtualbox</h1><h2 id="装载-Additions"><a href="#装载-Additions" class="headerlink" title="装载 Additions"></a>装载 Additions</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/cdrom /media/ -o loop</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /media</span><br><span class="line"></span><br><span class="line">sudo ./VBoxLinuxAdditions.run</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -a vboxguest vboxsf vboxvideo</span><br><span class="line">sudo mount -t vboxsf &lt;NAME&gt; /mnt/shared/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VMware-Functions&quot;&gt;&lt;a href=&quot;#VMware-Functions&quot; class=&quot;headerlink&quot; title=&quot;VMware Functions&quot;&gt;&lt;/a&gt;VMware Functions&lt;/h1&gt;&lt;p&gt;试试这个&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="virtual machine" scheme="http://wiki.yanick.site/categories/virtual-machine/"/>
    
    
  </entry>
  
  <entry>
    <title>Clion中管理Makefile项目</title>
    <link href="http://wiki.yanick.site/wiki/tools/ide/work-with-makefile-in-clion/"/>
    <id>http://wiki.yanick.site/wiki/tools/ide/work-with-makefile-in-clion/</id>
    <published>2020-06-06T16:27:50.000Z</published>
    <updated>2020-06-25T13:59:35.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tut"><a href="#Tut" class="headerlink" title="Tut"></a>Tut</h1><h2 id="安装-PIP"><a href="#安装-PIP" class="headerlink" title="安装 PIP"></a>安装 PIP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br></pre></td></tr></table></figure><h2 id="install-compiledb"><a href="#install-compiledb" class="headerlink" title="install compiledb"></a>install compiledb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install compiledb</span><br></pre></td></tr></table></figure><h2 id="compile-db"><a href="#compile-db" class="headerlink" title="compile db"></a>compile db</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiledb -n make</span><br></pre></td></tr></table></figure><h2 id="install-plugin-for-clion"><a href="#install-plugin-for-clion" class="headerlink" title="install plugin for clion"></a>install plugin for clion</h2><p>skip</p><h2 id="open-project"><a href="#open-project" class="headerlink" title="open project"></a>open project</h2><p>CLion will detect the compile_commands.json file and look in there for its project information. You may see it think about it for a few seconds, then show the “Compiler Info” tab on the Build tool window, telling you that everything finished ok (there were any errors or warnings you’ll see them in the “Sync” tab).</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.jetbrains.com/clion/2018/08/working-with-makefiles-in-clion-using-compilation-db/" rel="external nofollow noopener noreferrer" target="_blank">Working with Makefiles in CLion using Compilation DB</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tut&quot;&gt;&lt;a href=&quot;#Tut&quot; class=&quot;headerlink&quot; title=&quot;Tut&quot;&gt;&lt;/a&gt;Tut&lt;/h1&gt;&lt;h2 id=&quot;安装-PIP&quot;&gt;&lt;a href=&quot;#安装-PIP&quot; class=&quot;headerlink&quot; title=&quot;安装 PIP&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="tools" scheme="http://wiki.yanick.site/categories/tools/"/>
    
      <category term="ide" scheme="http://wiki.yanick.site/categories/tools/ide/"/>
    
      <category term="clion" scheme="http://wiki.yanick.site/categories/tools/ide/clion/"/>
    
    
  </entry>
  
  <entry>
    <title>构建与调试 Linux 内核</title>
    <link href="http://wiki.yanick.site/wiki/linux/build-and-debug-kernel/"/>
    <id>http://wiki.yanick.site/wiki/linux/build-and-debug-kernel/</id>
    <published>2020-05-15T16:09:25.000Z</published>
    <updated>2020-06-25T13:59:35.970Z</updated>
    
    <content type="html"><![CDATA[<p>本文以读者的 Linux 4.19 为构建目标</p><h1 id="构建Linux内核"><a href="#构建Linux内核" class="headerlink" title="构建Linux内核"></a>构建Linux内核</h1><h2 id="安装-GCC"><a href="#安装-GCC" class="headerlink" title="安装 GCC"></a>安装 GCC</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># 选择 kernel hacking —&gt; [*] compile the kernel with debug info 让其携带调试信息</span></span><br><span class="line">make defconfig 生成配置文件</span><br><span class="line">make 编译kernel</span><br></pre></td></tr></table></figure><h1 id="准备运行环境"><a href="#准备运行环境" class="headerlink" title="准备运行环境"></a>准备运行环境</h1><p>因为我们只有一个 <code>Kerenl</code>，我们还需要可以运行的 <code>rootfs</code> 等，最简单的方式是基于已经成熟的 Linux 发行版进行替换内核的方式进行运行。</p><h2 id="准备-Ubuntu-镜像"><a href="#准备-Ubuntu-镜像" class="headerlink" title="准备 Ubuntu 镜像"></a>准备 Ubuntu 镜像</h2><p>在 <code>Virtualbox</code> 中安装 <code>ubuntu server 14.04</code></p><h2 id="增加-kgdb-启动参数"><a href="#增加-kgdb-启动参数" class="headerlink" title="增加 kgdb 启动参数"></a>增加 <code>kgdb</code> 启动参数</h2><p>在 /etc/default/grub 中增加 <code>kgdb</code> 的启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kgdbwait kgdboc=ttyS0,115200 sysrq_always_enabled nokaslr</span><br></pre></td></tr></table></figure><h2 id="给宿主机增加串口虚拟文件"><a href="#给宿主机增加串口虚拟文件" class="headerlink" title="给宿主机增加串口虚拟文件"></a>给宿主机增加串口虚拟文件</h2><p>在virtualbox的settings里面选择serial port，勾选enable serial port，之后取消勾选connect to existing pipe/socket。port number、irq、I/O port就使用默认，port mode选择HOST PIPE，下面的目录填上/tmp/serial。</p><h2 id="替换我们的内核镜像"><a href="#替换我们的内核镜像" class="headerlink" title="替换我们的内核镜像"></a>替换我们的内核镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><hr><p>最后一步就是直接重启我们的系统，这个时候你会发现系统停留在启动页面了。</p><h1 id="连接系统进行调试"><a href="#连接系统进行调试" class="headerlink" title="连接系统进行调试"></a>连接系统进行调试</h1><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat -d -d /tmp/serial PTY</span><br></pre></td></tr></table></figure><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb vmlinux</span><br><span class="line">target remote /dev/pts/1</span><br></pre></td></tr></table></figure><h2 id="回复debug模式"><a href="#回复debug模式" class="headerlink" title="回复debug模式"></a>回复debug模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> g &gt; /dev/sysrq-trigger</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.0x972.info/?d=2014/11/27/18/45/48-linux-kernel-system-debugging-part-1-system-setup" rel="external nofollow noopener noreferrer" target="_blank">Linux Kernel System Debugging, part 1: System Setup</a></li><li><a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/" rel="external nofollow noopener noreferrer" target="_blank">Booting a Custom Linux Kernel in QEMU and Debugging It With GDB</a></li><li><a href="https://blog.csdn.net/gouxf_0219/article/details/82018970" rel="external nofollow noopener noreferrer" target="_blank">gcc: error: elf_x86_64: No such file or directory</a></li><li><a href="https://www.kernel.org/doc/html/v4.14/dev-tools/kgdb.html" rel="external nofollow noopener noreferrer" target="_blank">kgdb</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文以读者的 Linux 4.19 为构建目标&lt;/p&gt;
&lt;h1 id=&quot;构建Linux内核&quot;&gt;&lt;a href=&quot;#构建Linux内核&quot; class=&quot;headerlink&quot; title=&quot;构建Linux内核&quot;&gt;&lt;/a&gt;构建Linux内核&lt;/h1&gt;&lt;h2 id=&quot;安装-GCC
      
    
    </summary>
    
      <category term="linux" scheme="http://wiki.yanick.site/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Xbindkey</title>
    <link href="http://wiki.yanick.site/wiki/linux/xbindkey/"/>
    <id>http://wiki.yanick.site/wiki/linux/xbindkey/</id>
    <published>2020-05-04T16:27:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xbindkeys xautomation wish</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xbindkeys --defaults &gt; <span class="variable">$HOME</span>/.xbindkeysrc</span><br></pre></td></tr></table></figure><h1 id="Media-Btn"><a href="#Media-Btn" class="headerlink" title="Media Btn"></a>Media Btn</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Next"</span></span><br><span class="line"> b:8</span><br><span class="line"></span><br><span class="line"><span class="string">"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause"</span></span><br><span class="line"> b:2</span><br><span class="line"></span><br><span class="line"><span class="string">"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Previous"</span></span><br><span class="line"> b:9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="linux" scheme="http://wiki.yanick.site/categories/linux/"/>
    
      <category term="usage" scheme="http://wiki.yanick.site/categories/linux/usage/"/>
    
    
  </entry>
  
  <entry>
    <title>Rustup by USTC</title>
    <link href="http://wiki.yanick.site/wiki/tools/rustup/"/>
    <id>http://wiki.yanick.site/wiki/tools/rustup/</id>
    <published>2019-11-22T15:10:08.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RUSTUP"><a href="#RUSTUP" class="headerlink" title="RUSTUP"></a>RUSTUP</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static rustup update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RUSTUP&quot;&gt;&lt;a href=&quot;#RUSTUP&quot; class=&quot;headerlink&quot; title=&quot;RUSTUP&quot;&gt;&lt;/a&gt;RUSTUP&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="tools" scheme="http://wiki.yanick.site/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>容器网络Debug工具箱</title>
    <link href="http://wiki.yanick.site/wiki/tools/net-debug/"/>
    <id>http://wiki.yanick.site/wiki/tools/net-debug/</id>
    <published>2019-11-18T15:10:08.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Net-Tools"><a href="#Net-Tools" class="headerlink" title="Net Tools"></a>Net Tools</h2><h3 id="查询服务内部TCP状态"><a href="#查询服务内部TCP状态" class="headerlink" title="查询服务内部TCP状态"></a>查询服务内部TCP状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATTERN=redis sh -c <span class="string">"nsenter -t `docker ps  | grep <span class="variable">$PATTERN</span> | awk '&#123;print <span class="variable">$1</span>&#125;' | xargs  docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;'` -n netstat -ntuo"</span></span><br></pre></td></tr></table></figure><h2 id="Mac下容器内部访问宿主机网络"><a href="#Mac下容器内部访问宿主机网络" class="headerlink" title="Mac下容器内部访问宿主机网络"></a>Mac下容器内部访问宿主机网络</h2><blockquote><blockquote><p>Use your internal IP address or connect to the special DNS name <strong>host.docker.internal</strong> which will resolve to the internal IP address used by the host.</p></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host.docker.internal</span><br></pre></td></tr></table></figure><h2 id="快速启动一个Echo服务"><a href="#快速启动一个Echo服务" class="headerlink" title="快速启动一个Echo服务"></a>快速启动一个Echo服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -l 2000 --keep-open --<span class="built_in">exec</span> <span class="string">"/bin/cat"</span></span><br></pre></td></tr></table></figure><h2 id="Net-Tools-Continar"><a href="#Net-Tools-Continar" class="headerlink" title="Net Tools Continar"></a>Net Tools Continar</h2><p>推荐使用 <a href="https://github.com/nicolaka/netshoot" rel="external nofollow noopener noreferrer" target="_blank">netshoot</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">      - name: nettool</span><br><span class="line">        image: nicolaka/netshoot</span><br><span class="line">        <span class="built_in">command</span>: [ <span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"--"</span> ]</span><br><span class="line">        args: [ <span class="string">"while true; do sleep 30; done;"</span> ]</span><br></pre></td></tr></table></figure><h1 id="IPtables"><a href="#IPtables" class="headerlink" title="IPtables"></a>IPtables</h1><h2 id="将某Port的请求转发到另外一个Port"><a href="#将某Port的请求转发到另外一个Port" class="headerlink" title="将某Port的请求转发到另外一个Port"></a>将某Port的请求转发到另外一个Port</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I PREROUTING --src 0/0 --dst 172.17.0.2 -p tcp --dport 2526 -j REDIRECT --to-ports 2000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Net-Tools&quot;&gt;&lt;a href=&quot;#Net-Tools&quot; class=&quot;headerlink&quot; title=&quot;Net Tools&quot;&gt;&lt;/a&gt;Net Tools&lt;/h2&gt;&lt;h3 id=&quot;查询服务内部TCP状态&quot;&gt;&lt;a href=&quot;#查询服务内部TCP状态&quot; c
      
    
    </summary>
    
      <category term="tools" scheme="http://wiki.yanick.site/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>镜像站快速替换</title>
    <link href="http://wiki.yanick.site/wiki/tools/mirrors/"/>
    <id>http://wiki.yanick.site/wiki/tools/mirrors/</id>
    <published>2019-11-06T16:27:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alpine"><a href="#alpine" class="headerlink" title="alpine"></a>alpine</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g'</span> /etc/apk/repositories</span><br></pre></td></tr></table></figure><h1 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">'s/deb.debian.org/mirrors.ustc.edu.cn/g'</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">'s|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g'</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">'s/archive.ubuntu.com/mirrors.ustc.edu.cn/g'</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;alpine&quot;&gt;&lt;a href=&quot;#alpine&quot; class=&quot;headerlink&quot; title=&quot;alpine&quot;&gt;&lt;/a&gt;alpine&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="tools" scheme="http://wiki.yanick.site/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>kube 快速安装</title>
    <link href="http://wiki.yanick.site/wiki/k8s/quick-start/"/>
    <id>http://wiki.yanick.site/wiki/k8s/quick-start/</id>
    <published>2019-10-28T16:27:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宿主机设置"><a href="#宿主机设置" class="headerlink" title="宿主机设置"></a>宿主机设置</h1><h2 id="关闭-交换分区"><a href="#关闭-交换分区" class="headerlink" title="关闭 交换分区"></a>关闭 交换分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h2 id="设置Hostname和host"><a href="#设置Hostname和host" class="headerlink" title="设置Hostname和host"></a>设置Hostname和host</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl <span class="built_in">set</span>-hostname &lt;your-name&gt;</span><br><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="本机搞个VPN-amp-设置好代理"><a href="#本机搞个VPN-amp-设置好代理" class="headerlink" title="本机搞个VPN &amp; 设置好代理"></a>本机搞个VPN &amp; 设置好代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://naso.yannxia.top:8123</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://naso.yannxia.top:8123</span><br><span class="line"><span class="built_in">export</span> ftp_proxy=http://naso.yannxia.top:8123</span><br><span class="line"><span class="built_in">export</span> no_proxy=localhost,127.0.0.0,127.0.1.1,127.0.1.1,10.0.0.0/8,172.16.0.0/16,192.168.0.0/16,mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h2 id="设置Docker代理"><a href="#设置Docker代理" class="headerlink" title="设置Docker代理"></a>设置Docker代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://naso.yannxia.top:8123/"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=localhost,127.0.0.0/8,10.0.0.0/8,192.168.0.0/16,172.16.0.0/16,su0d0vi9.mirror.aliyuncs.com"</span></span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="K8s-安装"><a href="#K8s-安装" class="headerlink" title="K8s 安装"></a>K8s 安装</h1><h1 id="安装Kubadmin"><a href="#安装Kubadmin" class="headerlink" title="安装Kubadmin"></a>安装Kubadmin</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://apt.kubernetes.io/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h1 id="初始化节点"><a href="#初始化节点" class="headerlink" title="初始化节点"></a>初始化节点</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 172.16.80.135 --pod-network-cidr=192.168.0.0/16</span><br></pre></td></tr></table></figure><h1 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.11/manifests/calico.yaml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;宿主机设置&quot;&gt;&lt;a href=&quot;#宿主机设置&quot; class=&quot;headerlink&quot; title=&quot;宿主机设置&quot;&gt;&lt;/a&gt;宿主机设置&lt;/h1&gt;&lt;h2 id=&quot;关闭-交换分区&quot;&gt;&lt;a href=&quot;#关闭-交换分区&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="cncf" scheme="http://wiki.yanick.site/categories/cncf/"/>
    
      <category term="kubernetes" scheme="http://wiki.yanick.site/categories/cncf/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>写给 Java 开发者的 Kotlin 教程</title>
    <link href="http://wiki.yanick.site/wiki/links/kotlin/"/>
    <id>http://wiki.yanick.site/wiki/links/kotlin/</id>
    <published>2018-08-14T09:32:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.yannxia.top/2018/07/09/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-overview-installation-setup/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (1) - 概述</a></p><p><a href="http://blog.yannxia.top/2018/07/10/kotlin/easy-way-to-kotlin-for-java-proggamer/basic-syntax/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (2) - 基础语法</a></p><p><a href="http://blog.yannxia.top/2018/07/11/kotlin/easy-way-to-kotlin-for-java-proggamer/data-types/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (3) - 数据类型</a></p><p><a href="http://blog.yannxia.top/2018/07/12/kotlin/easy-way-to-kotlin-for-java-proggamer/control-flow/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (4) - 控制流表达式</a></p><p><a href="http://blog.yannxia.top/2018/07/17/kotlin/easy-way-to-kotlin-for-java-proggamer/null-type/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (5) - Null对象与类型安全</a></p><p><a href="http://blog.yannxia.top/2018/07/22/kotlin/easy-way-to-kotlin-for-java-proggamer/functions/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (6) - 函数基础</a></p><p><a href="http://blog.yannxia.top/2018/07/25/kotlin/easy-way-to-kotlin-for-java-proggamer/functions-advance/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (7) - 函数高阶</a></p><p><a href="http://blog.yannxia.top/2018/08/03/kotlin/easy-way-to-kotlin-for-java-proggamer/oop-basic/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (8) - 面向对象 - 基础</a></p><p><a href="http://blog.yannxia.top/2018/08/07/kotlin/easy-way-to-kotlin-for-java-proggamer/oop-class-with-properties/" rel="external nofollow noopener noreferrer" target="_blank">写给 Java 开发者的 Kotlin 教程 (9) - 面向对象 - 属性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.yannxia.top/2018/07/09/kotlin/easy-way-to-kotlin-for-java-proggamer/kotlin-overview-installation-setup/&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="java" scheme="http://wiki.yanick.site/categories/java/"/>
    
      <category term="kotlin" scheme="http://wiki.yanick.site/categories/java/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>CyclicBarrier 详解</title>
    <link href="http://wiki.yanick.site/wiki/java/cyclic-barrier/"/>
    <id>http://wiki.yanick.site/wiki/java/cyclic-barrier/</id>
    <published>2018-05-25T17:32:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.</p></blockquote><p>如Docs中所言，一个同步的工具能够让所有的线程等到一个集中点再继续执行。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>Future 是一个还算是见的接口，我们看看究竟是怎么实现的。它有多个实现类，我们看下最为重要的</p><blockquote><p>java.util.concurrent.FutureTask</p></blockquote><h2 id="TASK-STATE"><a href="#TASK-STATE" class="headerlink" title="TASK STATE"></a>TASK STATE</h2><p>我们可以看见这个类最上面就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>; <span class="comment">//新建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; <span class="comment">//结束中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; <span class="comment">//正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; <span class="comment">//异常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; <span class="comment">//取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">//中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>; <span class="comment">//已中断</span></span><br></pre></td></tr></table></figure><p>这里其实就是这个任务所能够转换的状态，这里的单词都很容易理解，我也添加了备注。在代码的备注中有一个很重要的说明</p><p>状态的变化可以是这样的:</p><ul><li>NEW -&gt; COMPLETING -&gt; NORMAL</li><li>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</li><li>NEW -&gt; CANCELLED</li><li>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li></ul><h2 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h2><p>我们来看看最常用的Get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，也就是获得当前的状态，我们判断状态如果是 COMPLETING 或者 NEW （这里用 &lt;= ）我们就去等待，其他的情况直接就返回结果。见report函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也就是根据返回的结果，如果是正常结束就返回，其他就返回异常。我们再来看看 awaitDone 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>; <span class="comment">//➀</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//➁</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123; <span class="comment">//➂</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">//➃ cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos); <span class="comment">//➄</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>); <span class="comment">//➅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的代码就复杂点了，我们从上到下慢慢看起来。<br>➀ 这里如果有超时时间的话，就是一个值，其他的就是0<br>➁ 这里如果运行的线程已经中断了，那我们就直接抛出异常就好了，最简单的部分。<br>➂ 如果结束了，我们需要返回状态即可。<br>➃ 因为我们的任务已经完成了，只是在等待结果导出，所以这里不能再计算超时，我们直接把线程让出来就行。<br>➄ 这里也就是将自己Blocking住需要超时的时间。<br>➅ 如果没有超时的设置，我们就将自己一直Blocking住</p><p>那问题又来了，我们什么时候才能够将自己唤醒呢？秘密就在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">//➀</span></span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode next = q.next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">//➁</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>➀ 在这里我们释放在awaitDone被Blocking的线程，这个时候继续运行下去，如果结果还是没有又会在 awaitDone 中新创建一个 WaitNode 然后被在awaitDone中被释放，直到 ➁ 完全没有任务可言的时候就算是结束。</p><blockquote><p>这里有点绕的原因是因为 ➀ awaitDone 的循环中如果任务没有完成 -&gt; ➁ awaitDone 的当前线程（主线程）被 Blocking -&gt; ➂ finishCompletion 的运行线程（也就是任务的本体）如果任务还没有完成 -&gt; ➃ 唤醒 awaitDone的线程（主线程） -&gt; ➀</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/cz123/p/7693064.html" rel="external nofollow noopener noreferrer" target="_blank">彻底理解Java的Future模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarrier
      
    
    </summary>
    
      <category term="java" scheme="http://wiki.yanick.site/categories/java/"/>
    
      <category term="异步与并发编程" scheme="http://wiki.yanick.site/categories/java/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读回顾模板</title>
    <link href="http://wiki.yanick.site/wiki/learn/book-review/"/>
    <id>http://wiki.yanick.site/wiki/learn/book-review/</id>
    <published>2018-05-06T16:13:58.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<p>Q: 简短的描述这本书在说什么？<br>A:</p><p>Q:这本书的大纲是怎么样构成的？<br>A:</p><p>Q: 作者细部说了什么，怎么说的？<br>A:</p><p>Q:这本书说得有道理吗？是全部有道理，还是部分有道理？<br>A:</p><p>Q: 找出作者在问的问题，或作者想要解决的问题。<br>A:</p><p>Q: 这本书跟你有什么关系？你从中获得什么？<br>A:</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/1013208/" rel="external nofollow noopener noreferrer" target="_blank">如何阅读一本书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Q: 简短的描述这本书在说什么？&lt;br&gt;A:&lt;/p&gt;
&lt;p&gt;Q:这本书的大纲是怎么样构成的？&lt;br&gt;A:&lt;/p&gt;
&lt;p&gt;Q: 作者细部说了什么，怎么说的？&lt;br&gt;A:&lt;/p&gt;
&lt;p&gt;Q:这本书说得有道理吗？是全部有道理，还是部分有道理？&lt;br&gt;A:&lt;/p&gt;
&lt;p&gt;Q: 找出
      
    
    </summary>
    
      <category term="technique" scheme="http://wiki.yanick.site/categories/technique/"/>
    
    
  </entry>
  
  <entry>
    <title>服务发现</title>
    <link href="http://wiki.yanick.site/wiki/microservice/service_discovery/"/>
    <id>http://wiki.yanick.site/wiki/microservice/service_discovery/</id>
    <published>2018-05-04T16:27:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于服务发现的定义"><a href="#关于服务发现的定义" class="headerlink" title="关于服务发现的定义"></a>关于服务发现的定义</h2><ul><li><a href="https://github.com/DocsHome/microservices/blob/master/4-service-discovery.md" rel="external nofollow noopener noreferrer" target="_blank">服务发现</a></li><li><a href="https://en.wikipedia.org/wiki/Service_discovery" rel="external nofollow noopener noreferrer" target="_blank">Wiki-Service_discovery</a></li></ul><p>这部分稍微要注意的是服务发现分为 <code>客户端发现模式</code>，<code>服务端发现模式</code>，Eureka 采用的是客户端发现的模式，这样职责单一，对于<br>服务端的要求也不会太高。</p><h2 id="关于服务发现的实现"><a href="#关于服务发现的实现" class="headerlink" title="关于服务发现的实现"></a>关于服务发现的实现</h2><ul><li><p>Eureka: Netflix 开源的服务发现，当前的1.0版本有几个问题</p><ul><li>全量更新</li><li>无一致性保证</li><li>非长连接，轮询保证服务健康</li></ul></li><li><p>Zookeeper: 很多老点的系统会使用这个，优点是有一致性协议保证，缺点也就是不太友好，需要理解它的概念。<br>主要通过虚节点来实现。</p></li><li><p>etcd: 本质上一个KeyValue的储存，这个也需要自己实现一个轮训的接口。</p></li><li><p>Consul: 我觉得这是最为完美的方案，有一致性协议保证，consul 自己实现了Client 和 Server</p></li></ul><p>SpringCloud对Eureka支持最好，Consul也有支持，其他的就完全需要自己搞一套了。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>其实作为底层服务，性能是需要重要考虑的特性。官网有一个performance。见参考资料</p><p><img src="https://coreos.com/sites/default/files/inline-images/2017Q1-00-cpu-1M-client-scaling.png" alt="2017Q1-00-cpu-1M-client-scaling"></p><p>整体看起来 Consul 和 etcd 是接近的，Zoo在大量的节点连接的时候CPU和内存都需要大量的占用，在微服务设计的时候需要考虑。</p><p>最后补充一个 <a href="https://home1-oss.github.io/home1-oss-gitbook/release/docs/oss-eureka/PERFORMANCE.html" rel="external nofollow noopener noreferrer" target="_blank">Eureka的性能测试</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://coreos.com/blog/performance-of-etcd.html" rel="external nofollow noopener noreferrer" target="_blank">performance-of-etcd</a></li><li><a href="https://home1-oss.github.io/home1-oss-gitbook/release/docs/oss-eureka/PERFORMANCE.html" rel="external nofollow noopener noreferrer" target="_blank">performance-of-eureka</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于服务发现的定义&quot;&gt;&lt;a href=&quot;#关于服务发现的定义&quot; class=&quot;headerlink&quot; title=&quot;关于服务发现的定义&quot;&gt;&lt;/a&gt;关于服务发现的定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/DocsHome
      
    
    </summary>
    
      <category term="architecture" scheme="http://wiki.yanick.site/categories/architecture/"/>
    
      <category term="microservices" scheme="http://wiki.yanick.site/categories/architecture/microservices/"/>
    
    
  </entry>
  
  <entry>
    <title>ClassLoader</title>
    <link href="http://wiki.yanick.site/wiki/java/classloader/"/>
    <id>http://wiki.yanick.site/wiki/java/classloader/</id>
    <published>2018-05-03T09:32:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassPath"><a href="#ClassPath" class="headerlink" title="ClassPath"></a>ClassPath</h2><blockquote><p>CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</p></blockquote><p>我们都记得在第一次配置Java的时候，我们需要配置CLASSPATH，Classpath是什么意思呢，其实Classpath就是如同<br>单词的意思一样，Class的路径。我们来看看Java的加载类的机制。</p><p><img src="http://www.javaenotes.com/wp-content/uploads/2016/12/Class-Loader-in-java.png" alt="ClassLoader"></p><ul><li>Bootstrap Class Loader – It loads JDK internal classes, typically loads rt.jar and other core classes for example java.lang.* package classes (通常是rt.jar的类，比如lang包下面的那些东西)</li><li>Extensions Class Loader – It loads classes from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory. （通常加载lib里面的class）</li><li>System Class Loader – It loads classes from the current classpath that can be set while invoking a program using -cp or -classpath command line options.（加载通过 -cp 传入的地址）</li></ul><p>那我们再看 <strong>CLASSPATH</strong> 原来就是定义rt.jar 和 lib 地址的。</p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>这里就不多说明了，给一个链接即可。<a href="http://www.cnblogs.com/ityouknow/p/5603287.html" rel="external nofollow noopener noreferrer" target="_blank">java类的加载机制</a></p><p>注意下 <em>双亲委派模型</em> 这个老生常谈的问题</p><p>双亲委派模型意义：</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行（防止恶性覆盖系统级别代码）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/ityouknow/p/5603287.html" rel="external nofollow noopener noreferrer" target="_blank">java类的加载机制</a></li><li><a href="https://www.journaldev.com/349/java-classloader" rel="external nofollow noopener noreferrer" target="_blank">Java ClassLoader</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ClassPath&quot;&gt;&lt;a href=&quot;#ClassPath&quot; class=&quot;headerlink&quot; title=&quot;ClassPath&quot;&gt;&lt;/a&gt;ClassPath&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CLASSPATH=.;%JAVA_HOME%\lib;%
      
    
    </summary>
    
      <category term="java" scheme="http://wiki.yanick.site/categories/java/"/>
    
      <category term="foundation" scheme="http://wiki.yanick.site/categories/java/foundation/"/>
    
    
  </entry>
  
  <entry>
    <title>如何工作</title>
    <link href="http://wiki.yanick.site/wiki/learn/how-to-work/"/>
    <id>http://wiki.yanick.site/wiki/learn/how-to-work/</id>
    <published>2018-04-24T18:43:08.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<p>本来我是不愿意写一个这么大的标题的，但是最近被工作缠身无法自拔，恰好一个同事也无心工作，还是回归下自己对于工作方法论的认知。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>大部分的讲工作的指导性书籍的核心思想我在这里做一个抽象升华：</p><blockquote><p>把注意力解放出来<br>想要赞成这个观点，第一步就是要承认，我们每一个的注意力是有限的，我们一天能够高效办公/学习的时候是一个浮动不大的值。<br>我们想要把自己的注意力释放到值得投入的事情上，这就是所有的工作指导手册的核心。</p></blockquote><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里面的方法论就多了点，我个人比较喜欢的是 《尽管去做GTD》 和 《吃掉那只青蛙》。<br>《吃掉那只青蛙》中会涉及更多对于整个职业生涯的规划，而《尽管去做GTD》会更加注重于实践。那实践起来的方式是怎么的。</p><blockquote><p>（1）收集一切引起我们注意力的事情；<br>（2）加工处理后，确定它们的实质以及解决方法；<br>（3）组织整理得出的结论；<br>（4）把它们列为我们行动的选择方案；<br>（5）行动，这就构成了我们生活中的“横向”管理层，随时添加新事务</p></blockquote><p>而在 《吃掉那只青蛙》 更是将工作的步骤分解为</p><blockquote><p>（1）树立目标；<br>（2）精心计划；<br>（3）排出优先级；<br>（4）循序渐进；<br>（5）精益求精；</p></blockquote><p>道理总是类似的，我们都知道我们做事情的时候要心无旁骛，为什么我们在做一件事情的时候还会浪费自己的精力去做其他的事情呢？</p><ul><li>影响注意的原因<ul><li>觉得手头的事情没意思；（无法从工作中获得乐趣）</li><li>觉得手机更有意思；（成为科技的奴隶）</li><li>还有其他的事情没做完；（引起我们注意力的事情太多）</li><li>生怕错过一切东西；（焦虑感）</li></ul></li></ul><p>显然除了第一点是难以改正的，其他的事情我们都应该从自己的身上找原因。世间的诱惑实在太多，如同在茫茫海洋中，我们只有找到灯塔<br>才能够顺利航行。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>没有银弹是世界的真理，而GTD只是工作的方法论，不是包治百病的良药。GTD的目标是帮我们完成目标，而不是指明我们究竟<br>应该怎么去找到自己的方向。</p><p>最后还是送大家 《诫子书》</p><blockquote><p>夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/3371165/" rel="external nofollow noopener noreferrer" target="_blank">吃掉那只青蛙</a></li><li><a href="https://book.douban.com/subject/1085660/" rel="external nofollow noopener noreferrer" target="_blank">尽管去做GTD</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来我是不愿意写一个这么大的标题的，但是最近被工作缠身无法自拔，恰好一个同事也无心工作，还是回归下自己对于工作方法论的认知。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="technique" scheme="http://wiki.yanick.site/categories/technique/"/>
    
    
  </entry>
  
  <entry>
    <title>如何学习</title>
    <link href="http://wiki.yanick.site/wiki/learn/how-to-learn/"/>
    <id>http://wiki.yanick.site/wiki/learn/how-to-learn/</id>
    <published>2018-04-18T17:48:58.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重要申明"><a href="#重要申明" class="headerlink" title="重要申明"></a>重要申明</h2><p>本人只是一个学渣，学习姿势因人而变，切勿盲目模仿。</p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>首先我们要承认我们学习的是<code>知识</code>和<code>技能</code>，也就是我们学习的是前人既定的一种最佳实践，这种感觉经常在面试的过程中有所体悟。比如Java面试的会问你知道Hashmap的实现，这种类型都是技能和知识，学习这一类型的知识我们是可以通过方法论得到提高的，至于才干部分，我个人觉得可能不仅仅是一个脑力活动也需要外在的关键点。</p><p><img src="https://wx1.sinaimg.cn/large/eddc95fcly1fqhr9d0tnfj20fk0aoaai.jpg" alt="知识的三种层次"></p><h3 id="Holistic-Learning-整体学习法"><a href="#Holistic-Learning-整体学习法" class="headerlink" title="Holistic Learning (整体学习法)"></a>Holistic Learning (整体学习法)</h3><p>这是国外的一个小哥总结出来的，当然也经过他自己的实践效果还是非凡的。<br>顺序是这样的：</p><ul><li>获取：也是划重点，获得知识的要点。</li><li>理解：理解知识基本含义，也就是在上下文的含义。</li><li>拓展：讲知识与已有的知识关联在一起，从而形成自己的知识网格。</li><li>纠错：反思。</li><li>应用：讲知识运用，可以是做题，可以是自己写项目。</li></ul><p>当然整体的路线也是螺旋上升的，并非是顺序执行的。</p><h3 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h3><p>这个方法论的核心更简单些。<strong>不断使用刻意练习的方式提高自己的心理表征</strong></p><p>解释 <strong>心理表征</strong>:心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物想对应的心理结构，或具体或形象。</p><ol><li>有目的的练习具有定义明确的特定目标。定义明确的具体目标，可以有效地用于引导你的练习，这里要把目标分解，并制定一个计划。</li><li>有目的的练习是专注的。想要取得进步，至少在练习的时候，必须完全把注意力集中在任务上。</li><li>有目的的练习包含反馈。不论在做什么事情，都需要反馈来准确辨别在哪些地方还有不足，以及怎么会存在这些不足。反馈可以是自己经过思考后提出的，也可以是别人给你提出的。</li><li>有目的的练习需要走出舒适区。如果你从来不迫使自己走出舒适区，便永远无法进步。</li></ol><h3 id="费曼技巧"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧</h3><p>费曼技巧是一种理解知识点的技巧。<br><img src="https://cdn-images-1.medium.com/max/1920/1*q426qg_oYXI8bUt9CuUtOg.jpeg" alt="费曼技巧"></p><p>其实我觉得费曼技巧其实和小黄鸭调试法都很像，也就是你自己真正搞得清楚的东西才能够将的出来。</p><h3 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h3><p>看过很多学习方法论的书，当然我还是坚信<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9" rel="external nofollow noopener noreferrer" target="_blank">没有银弹</a>。</p><p>没有一种学习方法是可以一劳永逸的，回到问题的之初，我们学的是<strong>技能</strong>和<strong>知识</strong>，都是别人的归纳总结，这些知识之间是有相互关联的，你如果想去了解一个人最好做和他一样的事情，差不多的道理，我们想要学会这样的知识，因为书本之上的知识已经是最终的表现，而推导的过程被隐藏掉了，那我们针对知识的学习过程就应该是 <code>收集证据</code> <code>分析证据</code> <code>提出假设</code> <code>论证假设</code> 的过程，其实也就对应着 <code>获取</code> <code>理解</code> <code>纠错</code> 这三个核心，而费曼技巧针对是复杂困难的问题我们如何处理，除此之外刻意练习提出是因为如果我们只是不断的循环没有目标是不行，刻意练习帮我们树立了目标。</p><p>当然我也没有多久的实践经验，在后续的实践中，我会给大家更多的反馈。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.scotthyoung.com/blog/sales-pages/learn-more-study-less/" rel="external nofollow noopener noreferrer" target="_blank">learn-more-study-less</a></li><li><a href="https://zhuanlan.zhihu.com/p/22244832?refer=career001" rel="external nofollow noopener noreferrer" target="_blank">还在按照兴趣选工作</a></li><li><a href="https://www.zhihu.com/question/20576786" rel="external nofollow noopener noreferrer" target="_blank">费曼技巧</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重要申明&quot;&gt;&lt;a href=&quot;#重要申明&quot; class=&quot;headerlink&quot; title=&quot;重要申明&quot;&gt;&lt;/a&gt;重要申明&lt;/h2&gt;&lt;p&gt;本人只是一个学渣，学习姿势因人而变，切勿盲目模仿。&lt;/p&gt;
&lt;h2 id=&quot;学习方法&quot;&gt;&lt;a href=&quot;#学习方法&quot; cl
      
    
    </summary>
    
      <category term="technique" scheme="http://wiki.yanick.site/categories/technique/"/>
    
    
  </entry>
  
  <entry>
    <title>Future 详解</title>
    <link href="http://wiki.yanick.site/wiki/java/future/"/>
    <id>http://wiki.yanick.site/wiki/java/future/</id>
    <published>2018-04-14T09:32:50.000Z</published>
    <updated>2020-06-17T07:24:40.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><p>Future 是一个还算是见的接口，我们看看究竟是怎么实现的。它有多个实现类，我们看下最为重要的</p><blockquote><p>java.util.concurrent.FutureTask</p></blockquote><h2 id="TASK-STATE"><a href="#TASK-STATE" class="headerlink" title="TASK STATE"></a>TASK STATE</h2><p>我们可以看见这个类最上面就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>; <span class="comment">//新建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; <span class="comment">//结束中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; <span class="comment">//正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; <span class="comment">//异常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; <span class="comment">//取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">//中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>; <span class="comment">//已中断</span></span><br></pre></td></tr></table></figure><p>这里其实就是这个任务所能够转换的状态，这里的单词都很容易理解，我也添加了备注。在代码的备注中有一个很重要的说明</p><p>状态的变化可以是这样的:</p><ul><li>NEW -&gt; COMPLETING -&gt; NORMAL</li><li>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</li><li>NEW -&gt; CANCELLED</li><li>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</li></ul><h2 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h2><p>我们来看看最常用的Get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码很简单，也就是获得当前的状态，我们判断状态如果是 COMPLETING 或者 NEW （这里用 &lt;= ）我们就去等待，其他的情况直接就返回结果。见report函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里也就是根据返回的结果，如果是正常结束就返回，其他就返回异常。我们再来看看 awaitDone 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>; <span class="comment">//➀</span></span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">//➁</span></span><br><span class="line">                removeWaiter(q); </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123; <span class="comment">//➂</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">//➃ cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos); <span class="comment">//➄</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>); <span class="comment">//➅</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的代码就复杂点了，我们从上到下慢慢看起来。<br>➀ 这里如果有超时时间的话，就是一个值，其他的就是0<br>➁ 这里如果运行的线程已经中断了，那我们就直接抛出异常就好了，最简单的部分。<br>➂ 如果结束了，我们需要返回状态即可。<br>➃ 因为我们的任务已经完成了，只是在等待结果导出，所以这里不能再计算超时，我们直接把线程让出来就行。<br>➄ 这里也就是将自己Blocking住需要超时的时间。<br>➅ 如果没有超时的设置，我们就将自己一直Blocking住</p><p>那问题又来了，我们什么时候才能够将自己唤醒呢？秘密就在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">//➀</span></span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode next = q.next;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>) <span class="comment">//➁</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>➀ 在这里我们释放在awaitDone被Blocking的线程，这个时候继续运行下去，如果结果还是没有又会在 awaitDone 中新创建一个 WaitNode 然后被在awaitDone中被释放，直到 ➁ 完全没有任务可言的时候就算是结束。</p><blockquote><p>这里有点绕的原因是因为 ➀ awaitDone 的循环中如果任务没有完成 -&gt; ➁ awaitDone 的当前线程（主线程）被 Blocking -&gt; ➂ finishCompletion 的运行线程（也就是任务的本体）如果任务还没有完成 -&gt; ➃ 唤醒 awaitDone的线程（主线程） -&gt; ➀</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/cz123/p/7693064.html" rel="external nofollow noopener noreferrer" target="_blank">彻底理解Java的Future模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="java" scheme="http://wiki.yanick.site/categories/java/"/>
    
      <category term="异步与并发编程" scheme="http://wiki.yanick.site/categories/java/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
