{"pages":[{"title":"books","date":"2018-04-23T15:22:05.000Z","path":"books/index.html","text":"TCP/IP 相关 链接: https://pan.baidu.com/s/1tNUZ0m8C3RNLSBtq4fTp8g 密码: bkp5"},{"title":"About","date":"2020-06-17T07:24:40.967Z","path":"about/index.html","text":"本网站作为 Yanick’s Blog 的支援性网站，将一些记录性质的东西放置于此。"},{"title":"Categories","date":"2020-06-17T07:24:40.967Z","path":"categories/index.html","text":""},{"title":"知识地图","date":"2018-04-19T12:11:20.000Z","path":"map/index.html","text":""},{"title":"Tags","date":"2020-06-17T07:24:40.967Z","path":"tags/index.html","text":""},{"title":"知识地图","date":"2018-04-19T12:11:20.000Z","path":"map/embed_page/index.html","text":"var mind = { \"meta\": { \"name\": \"Yann\", \"author\": \"me@yannxia.top\", \"version\": \"0.2\" }, \"format\": \"node_array\", \"data\": [ {\"id\":\"root\", \"isroot\":true, \"topic\":\"jsMind\"}, {\"id\":\"easy\", \"parentid\":\"root\", \"topic\":\"Easy\", \"direction\":\"left\"}, {\"id\":\"easy1\", \"parentid\":\"easy\", \"topic\":\"Easy to show\"}, {\"id\":\"easy2\", \"parentid\":\"easy\", \"topic\":\"Easy to edit\"}, {\"id\":\"easy3\", \"parentid\":\"easy\", \"topic\":\"Easy to store\"}, {\"id\":\"easy4\", \"parentid\":\"easy\", \"topic\":\"Easy to embed\"}, {\"id\":\"open\", \"parentid\":\"root\", \"topic\":\"Open Source\", \"expanded\":false, \"direction\":\"right\"}, {\"id\":\"open1\", \"parentid\":\"open\", \"topic\":\"on GitHub\"}, {\"id\":\"open2\", \"parentid\":\"open\", \"topic\":\"BSD License\"}, {\"id\":\"powerful\", \"parentid\":\"root\", \"topic\":\"Powerful\", \"direction\":\"right\"}, {\"id\":\"powerful1\", \"parentid\":\"powerful\", \"topic\":\"Base on Javascript\"}, {\"id\":\"powerful2\", \"parentid\":\"powerful\", \"topic\":\"Base on HTML5\"}, {\"id\":\"powerful3\", \"parentid\":\"powerful\", \"topic\":\"Depends on you\"}, ] }; var options = { container: 'jsmind_container', theme: 'info', editable: false }; var jm = new jsMind(options); jm.show(mind); jm.end_edit();"}],"posts":[{"title":"inoreader 无法显示图片","date":"2020-06-23T16:27:50.000Z","path":"wiki/tips/inoreader-can-not-show-pic/","text":"解决办法安装 referer control 禁止 inoreader 向第三方站点发送 referrer 参考 inoreader 图片不显示是什么情况","tags":[],"categories":[{"name":"tips","slug":"tips","permalink":"http://wiki.yanick.site/categories/tips/"}]},{"title":"Linux Device Driver 笔记","date":"2020-06-20T16:09:25.000Z","path":"wiki/linux/ldd/","text":"Prepare先下载 Linux 源码，然后准备到开发驱动的必须前置工作 123make oldconfigmake preparemake modules_prepare 编译 Helloworld123git clone https://github.com/vigith/Linux-Device-Drivers.gitmake -C /root/linux-2.6.32.4/ M=`pwd` modules -C: 指定 Linux 源码位置","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"http://wiki.yanick.site/categories/linux/"}]},{"title":"常见虚拟机挂载共享目录问题","date":"2020-06-06T16:27:50.000Z","path":"wiki/virtualmachine/mount-file/","text":"VMware Functions试试这个 1sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other Virtualbox装载 Additions1234567sudo mount /dev/cdrom /media/ -o loopcd /mediasudo ./VBoxLinuxAdditions.runreboot 载入12sudo modprobe -a vboxguest vboxsf vboxvideosudo mount -t vboxsf &lt;NAME&gt; /mnt/shared/","tags":[],"categories":[{"name":"virtual machine","slug":"virtual-machine","permalink":"http://wiki.yanick.site/categories/virtual-machine/"}]},{"title":"Clion中管理Makefile项目","date":"2020-06-06T16:27:50.000Z","path":"wiki/tools/ide/work-with-makefile-in-clion/","text":"Tut安装 PIP1sudo apt install python-pip install compiledb1pip install compiledb compile db1compiledb -n make install plugin for clionskip open projectCLion will detect the compile_commands.json file and look in there for its project information. You may see it think about it for a few seconds, then show the “Compiler Info” tab on the Build tool window, telling you that everything finished ok (there were any errors or warnings you’ll see them in the “Sync” tab). 参考 Working with Makefiles in CLion using Compilation DB","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"http://wiki.yanick.site/categories/tools/"},{"name":"ide","slug":"tools/ide","permalink":"http://wiki.yanick.site/categories/tools/ide/"},{"name":"clion","slug":"tools/ide/clion","permalink":"http://wiki.yanick.site/categories/tools/ide/clion/"}]},{"title":"构建与调试 Linux 内核","date":"2020-05-15T16:09:25.000Z","path":"wiki/linux/build-and-debug-kernel/","text":"本文以读者的 Linux 4.19 为构建目标 构建Linux内核安装 GCC1sudo apt install gcc 构建配置1234make menuconfig# 选择 kernel hacking —&gt; [*] compile the kernel with debug info 让其携带调试信息make defconfig 生成配置文件make 编译kernel 准备运行环境因为我们只有一个 Kerenl，我们还需要可以运行的 rootfs 等，最简单的方式是基于已经成熟的 Linux 发行版进行替换内核的方式进行运行。 准备 Ubuntu 镜像在 Virtualbox 中安装 ubuntu server 14.04 增加 kgdb 启动参数在 /etc/default/grub 中增加 kgdb 的启动参数 1kgdbwait kgdboc=ttyS0,115200 sysrq_always_enabled nokaslr 给宿主机增加串口虚拟文件在virtualbox的settings里面选择serial port，勾选enable serial port，之后取消勾选connect to existing pipe/socket。port number、irq、I/O port就使用默认，port mode选择HOST PIPE，下面的目录填上/tmp/serial。 替换我们的内核镜像1make install 最后一步就是直接重启我们的系统，这个时候你会发现系统停留在启动页面了。 连接系统进行调试attach1socat -d -d /tmp/serial PTY gdb12gdb vmlinuxtarget remote /dev/pts/1 回复debug模式1echo g &gt; /dev/sysrq-trigger 参考 Linux Kernel System Debugging, part 1: System Setup Booting a Custom Linux Kernel in QEMU and Debugging It With GDB gcc: error: elf_x86_64: No such file or directory kgdb","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"http://wiki.yanick.site/categories/linux/"}]},{"title":"Xbindkey","date":"2020-05-04T16:27:50.000Z","path":"wiki/linux/xbindkey/","text":"安装1sudo apt install xbindkeys xautomation wish 配置1xbindkeys --defaults &gt; $HOME/.xbindkeysrc Media Btn12345678\"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Next\" b:8\"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause\" b:2\"dbus-send --print-reply --dest=org.mpris.MediaPlayer2.netease-cloud-music /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Previous\" b:9","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"http://wiki.yanick.site/categories/linux/"},{"name":"usage","slug":"linux/usage","permalink":"http://wiki.yanick.site/categories/linux/usage/"}]},{"title":"Rustup by USTC","date":"2019-11-22T15:10:08.000Z","path":"wiki/tools/rustup/","text":"RUSTUP1RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static rustup update","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"http://wiki.yanick.site/categories/tools/"}]},{"title":"容器网络Debug工具箱","date":"2019-11-18T15:10:08.000Z","path":"wiki/tools/net-debug/","text":"Net Tools查询服务内部TCP状态1PATTERN=redis sh -c \"nsenter -t `docker ps | grep $PATTERN | awk '&#123;print $1&#125;' | xargs docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;'` -n netstat -ntuo\" Mac下容器内部访问宿主机网络 Use your internal IP address or connect to the special DNS name host.docker.internal which will resolve to the internal IP address used by the host. 1host.docker.internal 快速启动一个Echo服务1ncat -l 2000 --keep-open --exec \"/bin/cat\" Net Tools Continar推荐使用 netshoot 1234567891011121314151617181920212223apiVersion: v1kind: ReplicationControllermetadata: name: nginxspec: replicas: 2 selector: app: nginx template: metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 - name: nettool image: nicolaka/netshoot command: [ \"/bin/bash\", \"-c\", \"--\" ] args: [ \"while true; do sleep 30; done;\" ] IPtables将某Port的请求转发到另外一个Port1iptables -t nat -I PREROUTING --src 0/0 --dst 172.17.0.2 -p tcp --dport 2526 -j REDIRECT --to-ports 2000","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"http://wiki.yanick.site/categories/tools/"}]},{"title":"镜像站快速替换","date":"2019-11-06T16:27:50.000Z","path":"wiki/tools/mirrors/","text":"alpine1sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories Debian12sudo sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.listsudo sed -i 's|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g' /etc/apt/sources.list Ubuntu1sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"http://wiki.yanick.site/categories/tools/"}]},{"title":"kube 快速安装","date":"2019-10-28T16:27:50.000Z","path":"wiki/k8s/quick-start/","text":"宿主机设置关闭 交换分区1swapoff -a 设置Hostname和host12hostnamectl set-hostname &lt;your-name&gt;vim /etc/hosts 本机搞个VPN &amp; 设置好代理1234export http_proxy=http://naso.yannxia.top:8123export https_proxy=http://naso.yannxia.top:8123export ftp_proxy=http://naso.yannxia.top:8123export no_proxy=localhost,127.0.0.0,127.0.1.1,127.0.1.1,10.0.0.0/8,172.16.0.0/16,192.168.0.0/16,mirrors.aliyun.com 设置Docker代理123456mkdir -p /etc/systemd/system/docker.service.dvim /etc/systemd/system/docker.service.d/http-proxy.conf[Service]Environment=\"HTTP_PROXY=http://naso.yannxia.top:8123/\"Environment=\"NO_PROXY=localhost,127.0.0.0/8,10.0.0.0/8,192.168.0.0/16,172.16.0.0/16,su0d0vi9.mirror.aliyuncs.com\"systemctl daemon-reload &amp;&amp; systemctl restart docker K8s 安装安装Kubadmin1234567apt-get update &amp;&amp; apt-get install -y apt-transport-https curlcurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb http://apt.kubernetes.io/ kubernetes-xenial mainEOFapt-get updateapt-get install -y kubelet kubeadm kubectl 初始化节点1kubeadm init --apiserver-advertise-address 172.16.80.135 --pod-network-cidr=192.168.0.0/16 安装网络插件1kubectl apply -f https://docs.projectcalico.org/v3.11/manifests/calico.yaml","tags":[],"categories":[{"name":"cncf","slug":"cncf","permalink":"http://wiki.yanick.site/categories/cncf/"},{"name":"kubernetes","slug":"cncf/kubernetes","permalink":"http://wiki.yanick.site/categories/cncf/kubernetes/"}]},{"title":"写给 Java 开发者的 Kotlin 教程","date":"2018-08-14T09:32:50.000Z","path":"wiki/links/kotlin/","text":"写给 Java 开发者的 Kotlin 教程 (1) - 概述 写给 Java 开发者的 Kotlin 教程 (2) - 基础语法 写给 Java 开发者的 Kotlin 教程 (3) - 数据类型 写给 Java 开发者的 Kotlin 教程 (4) - 控制流表达式 写给 Java 开发者的 Kotlin 教程 (5) - Null对象与类型安全 写给 Java 开发者的 Kotlin 教程 (6) - 函数基础 写给 Java 开发者的 Kotlin 教程 (7) - 函数高阶 写给 Java 开发者的 Kotlin 教程 (8) - 面向对象 - 基础 写给 Java 开发者的 Kotlin 教程 (9) - 面向对象 - 属性","tags":[],"categories":[{"name":"java","slug":"java","permalink":"http://wiki.yanick.site/categories/java/"},{"name":"kotlin","slug":"java/kotlin","permalink":"http://wiki.yanick.site/categories/java/kotlin/"}]},{"title":"CyclicBarrier 详解","date":"2018-05-25T17:32:50.000Z","path":"wiki/java/cyclic-barrier/","text":"A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released. 如Docs中所言，一个同步的工具能够让所有的线程等到一个集中点再继续执行。 Overview123456public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; Future 是一个还算是见的接口，我们看看究竟是怎么实现的。它有多个实现类，我们看下最为重要的 java.util.concurrent.FutureTask TASK STATE我们可以看见这个类最上面就是 12345678private volatile int state;private static final int NEW = 0; //新建private static final int COMPLETING = 1; //结束中private static final int NORMAL = 2; //正常结束private static final int EXCEPTIONAL = 3; //异常结束private static final int CANCELLED = 4; //取消private static final int INTERRUPTING = 5; //中断中private static final int INTERRUPTED = 6; //已中断 这里其实就是这个任务所能够转换的状态，这里的单词都很容易理解，我也添加了备注。在代码的备注中有一个很重要的说明 状态的变化可以是这样的: NEW -&gt; COMPLETING -&gt; NORMAL NEW -&gt; COMPLETING -&gt; EXCEPTIONAL NEW -&gt; CANCELLED NEW -&gt; INTERRUPTING -&gt; INTERRUPTED Get 方法我们来看看最常用的Get方法。 123456public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); &#125; 代码很简单，也就是获得当前的状态，我们判断状态如果是 COMPLETING 或者 NEW （这里用 &lt;= ）我们就去等待，其他的情况直接就返回结果。见report函数。 12345678private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); &#125; 这里也就是根据返回的结果，如果是正常结束就返回，其他就返回异常。我们再来看看 awaitDone 函数 123456789101112131415161718192021222324252627282930313233343536private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; //➀ WaitNode q = null; boolean queued = false; for (;;) &#123; if (Thread.interrupted()) &#123; //➁ removeWaiter(q); throw new InterruptedException(); &#125; int s = state; if (s &gt; COMPLETING) &#123; //➂ if (q != null) q.thread = null; return s; &#125; else if (s == COMPLETING) //➃ cannot time out yet Thread.yield(); else if (q == null) q = new WaitNode(); else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; LockSupport.parkNanos(this, nanos); //➄ &#125; else LockSupport.park(this); //➅ &#125; &#125; 这里的代码就复杂点了，我们从上到下慢慢看起来。➀ 这里如果有超时时间的话，就是一个值，其他的就是0➁ 这里如果运行的线程已经中断了，那我们就直接抛出异常就好了，最简单的部分。➂ 如果结束了，我们需要返回状态即可。➃ 因为我们的任务已经完成了，只是在等待结果导出，所以这里不能再计算超时，我们直接把线程让出来就行。➄ 这里也就是将自己Blocking住需要超时的时间。➅ 如果没有超时的设置，我们就将自己一直Blocking住 那问题又来了，我们什么时候才能够将自己唤醒呢？秘密就在 123456789101112131415161718192021222324private void finishCompletion() &#123; // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) &#123; if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; for (;;) &#123; Thread t = q.thread; if (t != null) &#123; //➀ q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) //➁ break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); callable = null; // to reduce footprint &#125; ➀ 在这里我们释放在awaitDone被Blocking的线程，这个时候继续运行下去，如果结果还是没有又会在 awaitDone 中新创建一个 WaitNode 然后被在awaitDone中被释放，直到 ➁ 完全没有任务可言的时候就算是结束。 这里有点绕的原因是因为 ➀ awaitDone 的循环中如果任务没有完成 -&gt; ➁ awaitDone 的当前线程（主线程）被 Blocking -&gt; ➂ finishCompletion 的运行线程（也就是任务的本体）如果任务还没有完成 -&gt; ➃ 唤醒 awaitDone的线程（主线程） -&gt; ➀ 参考资料 彻底理解Java的Future模式","tags":[],"categories":[{"name":"java","slug":"java","permalink":"http://wiki.yanick.site/categories/java/"},{"name":"异步与并发编程","slug":"java/异步与并发编程","permalink":"http://wiki.yanick.site/categories/java/异步与并发编程/"}]},{"title":"阅读回顾模板","date":"2018-05-06T16:13:58.000Z","path":"wiki/learn/book-review/","text":"Q: 简短的描述这本书在说什么？A: Q:这本书的大纲是怎么样构成的？A: Q: 作者细部说了什么，怎么说的？A: Q:这本书说得有道理吗？是全部有道理，还是部分有道理？A: Q: 找出作者在问的问题，或作者想要解决的问题。A: Q: 这本书跟你有什么关系？你从中获得什么？A: 参考资料 如何阅读一本书","tags":[],"categories":[{"name":"technique","slug":"technique","permalink":"http://wiki.yanick.site/categories/technique/"}]},{"title":"服务发现","date":"2018-05-04T16:27:50.000Z","path":"wiki/microservice/service_discovery/","text":"关于服务发现的定义 服务发现 Wiki-Service_discovery 这部分稍微要注意的是服务发现分为 客户端发现模式，服务端发现模式，Eureka 采用的是客户端发现的模式，这样职责单一，对于服务端的要求也不会太高。 关于服务发现的实现 Eureka: Netflix 开源的服务发现，当前的1.0版本有几个问题 全量更新 无一致性保证 非长连接，轮询保证服务健康 Zookeeper: 很多老点的系统会使用这个，优点是有一致性协议保证，缺点也就是不太友好，需要理解它的概念。主要通过虚节点来实现。 etcd: 本质上一个KeyValue的储存，这个也需要自己实现一个轮训的接口。 Consul: 我觉得这是最为完美的方案，有一致性协议保证，consul 自己实现了Client 和 Server SpringCloud对Eureka支持最好，Consul也有支持，其他的就完全需要自己搞一套了。 性能测试其实作为底层服务，性能是需要重要考虑的特性。官网有一个performance。见参考资料 整体看起来 Consul 和 etcd 是接近的，Zoo在大量的节点连接的时候CPU和内存都需要大量的占用，在微服务设计的时候需要考虑。 最后补充一个 Eureka的性能测试 参考资料 performance-of-etcd performance-of-eureka","tags":[],"categories":[{"name":"architecture","slug":"architecture","permalink":"http://wiki.yanick.site/categories/architecture/"},{"name":"microservices","slug":"architecture/microservices","permalink":"http://wiki.yanick.site/categories/architecture/microservices/"}]},{"title":"ClassLoader","date":"2018-05-03T09:32:50.000Z","path":"wiki/java/classloader/","text":"ClassPath CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 我们都记得在第一次配置Java的时候，我们需要配置CLASSPATH，Classpath是什么意思呢，其实Classpath就是如同单词的意思一样，Class的路径。我们来看看Java的加载类的机制。 Bootstrap Class Loader – It loads JDK internal classes, typically loads rt.jar and other core classes for example java.lang.* package classes (通常是rt.jar的类，比如lang包下面的那些东西) Extensions Class Loader – It loads classes from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory. （通常加载lib里面的class） System Class Loader – It loads classes from the current classpath that can be set while invoking a program using -cp or -classpath command line options.（加载通过 -cp 传入的地址） 那我们再看 CLASSPATH 原来就是定义rt.jar 和 lib 地址的。 ClassLoader这里就不多说明了，给一个链接即可。java类的加载机制 注意下 双亲委派模型 这个老生常谈的问题 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行（防止恶性覆盖系统级别代码） 参考资料 java类的加载机制 Java ClassLoader","tags":[],"categories":[{"name":"java","slug":"java","permalink":"http://wiki.yanick.site/categories/java/"},{"name":"foundation","slug":"java/foundation","permalink":"http://wiki.yanick.site/categories/java/foundation/"}]},{"title":"如何工作","date":"2018-04-24T18:43:08.000Z","path":"wiki/learn/how-to-work/","text":"本来我是不愿意写一个这么大的标题的，但是最近被工作缠身无法自拔，恰好一个同事也无心工作，还是回归下自己对于工作方法论的认知。 原理大部分的讲工作的指导性书籍的核心思想我在这里做一个抽象升华： 把注意力解放出来想要赞成这个观点，第一步就是要承认，我们每一个的注意力是有限的，我们一天能够高效办公/学习的时候是一个浮动不大的值。我们想要把自己的注意力释放到值得投入的事情上，这就是所有的工作指导手册的核心。 实践这里面的方法论就多了点，我个人比较喜欢的是 《尽管去做GTD》 和 《吃掉那只青蛙》。《吃掉那只青蛙》中会涉及更多对于整个职业生涯的规划，而《尽管去做GTD》会更加注重于实践。那实践起来的方式是怎么的。 （1）收集一切引起我们注意力的事情；（2）加工处理后，确定它们的实质以及解决方法；（3）组织整理得出的结论；（4）把它们列为我们行动的选择方案；（5）行动，这就构成了我们生活中的“横向”管理层，随时添加新事务 而在 《吃掉那只青蛙》 更是将工作的步骤分解为 （1）树立目标；（2）精心计划；（3）排出优先级；（4）循序渐进；（5）精益求精； 道理总是类似的，我们都知道我们做事情的时候要心无旁骛，为什么我们在做一件事情的时候还会浪费自己的精力去做其他的事情呢？ 影响注意的原因 觉得手头的事情没意思；（无法从工作中获得乐趣） 觉得手机更有意思；（成为科技的奴隶） 还有其他的事情没做完；（引起我们注意力的事情太多） 生怕错过一切东西；（焦虑感） 显然除了第一点是难以改正的，其他的事情我们都应该从自己的身上找原因。世间的诱惑实在太多，如同在茫茫海洋中，我们只有找到灯塔才能够顺利航行。 反思没有银弹是世界的真理，而GTD只是工作的方法论，不是包治百病的良药。GTD的目标是帮我们完成目标，而不是指明我们究竟应该怎么去找到自己的方向。 最后还是送大家 《诫子书》 夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 参考资料 吃掉那只青蛙 尽管去做GTD","tags":[],"categories":[{"name":"technique","slug":"technique","permalink":"http://wiki.yanick.site/categories/technique/"}]},{"title":"如何学习","date":"2018-04-18T17:48:58.000Z","path":"wiki/learn/how-to-learn/","text":"重要申明本人只是一个学渣，学习姿势因人而变，切勿盲目模仿。 学习方法首先我们要承认我们学习的是知识和技能，也就是我们学习的是前人既定的一种最佳实践，这种感觉经常在面试的过程中有所体悟。比如Java面试的会问你知道Hashmap的实现，这种类型都是技能和知识，学习这一类型的知识我们是可以通过方法论得到提高的，至于才干部分，我个人觉得可能不仅仅是一个脑力活动也需要外在的关键点。 Holistic Learning (整体学习法)这是国外的一个小哥总结出来的，当然也经过他自己的实践效果还是非凡的。顺序是这样的： 获取：也是划重点，获得知识的要点。 理解：理解知识基本含义，也就是在上下文的含义。 拓展：讲知识与已有的知识关联在一起，从而形成自己的知识网格。 纠错：反思。 应用：讲知识运用，可以是做题，可以是自己写项目。 当然整体的路线也是螺旋上升的，并非是顺序执行的。 刻意练习这个方法论的核心更简单些。不断使用刻意练习的方式提高自己的心理表征 解释 心理表征:心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物想对应的心理结构，或具体或形象。 有目的的练习具有定义明确的特定目标。定义明确的具体目标，可以有效地用于引导你的练习，这里要把目标分解，并制定一个计划。 有目的的练习是专注的。想要取得进步，至少在练习的时候，必须完全把注意力集中在任务上。 有目的的练习包含反馈。不论在做什么事情，都需要反馈来准确辨别在哪些地方还有不足，以及怎么会存在这些不足。反馈可以是自己经过思考后提出的，也可以是别人给你提出的。 有目的的练习需要走出舒适区。如果你从来不迫使自己走出舒适区，便永远无法进步。 费曼技巧费曼技巧是一种理解知识点的技巧。 其实我觉得费曼技巧其实和小黄鸭调试法都很像，也就是你自己真正搞得清楚的东西才能够将的出来。 我的思考看过很多学习方法论的书，当然我还是坚信没有银弹。 没有一种学习方法是可以一劳永逸的，回到问题的之初，我们学的是技能和知识，都是别人的归纳总结，这些知识之间是有相互关联的，你如果想去了解一个人最好做和他一样的事情，差不多的道理，我们想要学会这样的知识，因为书本之上的知识已经是最终的表现，而推导的过程被隐藏掉了，那我们针对知识的学习过程就应该是 收集证据 分析证据 提出假设 论证假设 的过程，其实也就对应着 获取 理解 纠错 这三个核心，而费曼技巧针对是复杂困难的问题我们如何处理，除此之外刻意练习提出是因为如果我们只是不断的循环没有目标是不行，刻意练习帮我们树立了目标。 当然我也没有多久的实践经验，在后续的实践中，我会给大家更多的反馈。 参考资料 learn-more-study-less 还在按照兴趣选工作 费曼技巧","tags":[],"categories":[{"name":"technique","slug":"technique","permalink":"http://wiki.yanick.site/categories/technique/"}]},{"title":"Future 详解","date":"2018-04-14T09:32:50.000Z","path":"wiki/java/future/","text":"Overview123456public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; Future 是一个还算是见的接口，我们看看究竟是怎么实现的。它有多个实现类，我们看下最为重要的 java.util.concurrent.FutureTask TASK STATE我们可以看见这个类最上面就是 12345678private volatile int state;private static final int NEW = 0; //新建private static final int COMPLETING = 1; //结束中private static final int NORMAL = 2; //正常结束private static final int EXCEPTIONAL = 3; //异常结束private static final int CANCELLED = 4; //取消private static final int INTERRUPTING = 5; //中断中private static final int INTERRUPTED = 6; //已中断 这里其实就是这个任务所能够转换的状态，这里的单词都很容易理解，我也添加了备注。在代码的备注中有一个很重要的说明 状态的变化可以是这样的: NEW -&gt; COMPLETING -&gt; NORMAL NEW -&gt; COMPLETING -&gt; EXCEPTIONAL NEW -&gt; CANCELLED NEW -&gt; INTERRUPTING -&gt; INTERRUPTED Get 方法我们来看看最常用的Get方法。 123456public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); &#125; 代码很简单，也就是获得当前的状态，我们判断状态如果是 COMPLETING 或者 NEW （这里用 &lt;= ）我们就去等待，其他的情况直接就返回结果。见report函数。 12345678private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); &#125; 这里也就是根据返回的结果，如果是正常结束就返回，其他就返回异常。我们再来看看 awaitDone 函数 123456789101112131415161718192021222324252627282930313233343536private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; //➀ WaitNode q = null; boolean queued = false; for (;;) &#123; if (Thread.interrupted()) &#123; //➁ removeWaiter(q); throw new InterruptedException(); &#125; int s = state; if (s &gt; COMPLETING) &#123; //➂ if (q != null) q.thread = null; return s; &#125; else if (s == COMPLETING) //➃ cannot time out yet Thread.yield(); else if (q == null) q = new WaitNode(); else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; LockSupport.parkNanos(this, nanos); //➄ &#125; else LockSupport.park(this); //➅ &#125; &#125; 这里的代码就复杂点了，我们从上到下慢慢看起来。➀ 这里如果有超时时间的话，就是一个值，其他的就是0➁ 这里如果运行的线程已经中断了，那我们就直接抛出异常就好了，最简单的部分。➂ 如果结束了，我们需要返回状态即可。➃ 因为我们的任务已经完成了，只是在等待结果导出，所以这里不能再计算超时，我们直接把线程让出来就行。➄ 这里也就是将自己Blocking住需要超时的时间。➅ 如果没有超时的设置，我们就将自己一直Blocking住 那问题又来了，我们什么时候才能够将自己唤醒呢？秘密就在 123456789101112131415161718192021222324private void finishCompletion() &#123; // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) &#123; if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; for (;;) &#123; Thread t = q.thread; if (t != null) &#123; //➀ q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) //➁ break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); callable = null; // to reduce footprint &#125; ➀ 在这里我们释放在awaitDone被Blocking的线程，这个时候继续运行下去，如果结果还是没有又会在 awaitDone 中新创建一个 WaitNode 然后被在awaitDone中被释放，直到 ➁ 完全没有任务可言的时候就算是结束。 这里有点绕的原因是因为 ➀ awaitDone 的循环中如果任务没有完成 -&gt; ➁ awaitDone 的当前线程（主线程）被 Blocking -&gt; ➂ finishCompletion 的运行线程（也就是任务的本体）如果任务还没有完成 -&gt; ➃ 唤醒 awaitDone的线程（主线程） -&gt; ➀ 参考资料 彻底理解Java的Future模式","tags":[],"categories":[{"name":"java","slug":"java","permalink":"http://wiki.yanick.site/categories/java/"},{"name":"异步与并发编程","slug":"java/异步与并发编程","permalink":"http://wiki.yanick.site/categories/java/异步与并发编程/"}]}],"categories":[{"name":"tips","slug":"tips","permalink":"http://wiki.yanick.site/categories/tips/"},{"name":"linux","slug":"linux","permalink":"http://wiki.yanick.site/categories/linux/"},{"name":"virtual machine","slug":"virtual-machine","permalink":"http://wiki.yanick.site/categories/virtual-machine/"},{"name":"tools","slug":"tools","permalink":"http://wiki.yanick.site/categories/tools/"},{"name":"ide","slug":"tools/ide","permalink":"http://wiki.yanick.site/categories/tools/ide/"},{"name":"clion","slug":"tools/ide/clion","permalink":"http://wiki.yanick.site/categories/tools/ide/clion/"},{"name":"usage","slug":"linux/usage","permalink":"http://wiki.yanick.site/categories/linux/usage/"},{"name":"cncf","slug":"cncf","permalink":"http://wiki.yanick.site/categories/cncf/"},{"name":"kubernetes","slug":"cncf/kubernetes","permalink":"http://wiki.yanick.site/categories/cncf/kubernetes/"},{"name":"java","slug":"java","permalink":"http://wiki.yanick.site/categories/java/"},{"name":"kotlin","slug":"java/kotlin","permalink":"http://wiki.yanick.site/categories/java/kotlin/"},{"name":"异步与并发编程","slug":"java/异步与并发编程","permalink":"http://wiki.yanick.site/categories/java/异步与并发编程/"},{"name":"technique","slug":"technique","permalink":"http://wiki.yanick.site/categories/technique/"},{"name":"architecture","slug":"architecture","permalink":"http://wiki.yanick.site/categories/architecture/"},{"name":"microservices","slug":"architecture/microservices","permalink":"http://wiki.yanick.site/categories/architecture/microservices/"},{"name":"foundation","slug":"java/foundation","permalink":"http://wiki.yanick.site/categories/java/foundation/"}],"tags":[]}